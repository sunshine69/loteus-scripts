#!/bin/sh
### linuxc script by fanthom <http://www.porteus.org>
### Rework to support many features by stevek for his usage

# These staging apple bce tested with macbook pro 2018 but for 2019 it crashes if second monitor connected at boot.

export PATH=/bin:/usr/bin:./
mount -nt proc proc /proc
echo "`cat /proc/cmdline|sed -e 's/^/ /'`" > /etc/cmdline
umount /proc
param() { egrep -qo " $1( |\$)" /etc/cmdline; }
value() { egrep -o " $1=[^ ]+" /etc/cmdline | cut -d= -f2- ; }
debug() { param debug && { echo -e "\n=====\n: Debugging started. Here is the shell for you.\n: Type your desired commands, hit Ctrl+D to continue booting\n: or press Ctrl+Alt+Del to reboot."; sh; echo -e "\n\n"; }; }
# Enable pivot_root in initramfs to let it behave like initrd: we need that because aufs not work on initrd but works on tmpfs
KMODS=`value kmods`
if [ -d /m ]; then
    echo "Start to load modules from initrd ..."
    if [ -d /lib/modules/`uname -r` ]; then
      if [ ! -z "$KMODS" ]; then KMODS=$(echo $KMODS | sed 's/,/ /'); fi
      # essiv is for crypt dm, crc32 for f2fs - these are not auto load when main modules loads for some reason
      for MODULE in $KMODS nvme-core nvme essiv crc32 libcrc32c thunderbolt hid-apple mac_hid applesmc apple_ibridge apple_bce apple_bl apple_ib_als applespi input_polldev mbcache ntfs3 overlay exportfs ext4 fat vfat fuse isofs nls_cp437 nls_iso8859-1 nls_utf8 squashfs udf xfs btrfs f2fs libata ahci libahci sata_sil24 pdc_adma sata_qstor sata_sx4 ata_piix sata_mv sata_nv sata_promise sata_sil sata_sis sata_svw sata_uli sata_via sata_vsc loop cdrom hid usbhid mptscsih mptspi mptsas tifm_core cb710 mmc_block mmc_core sdhci sdhci-pci wbsd tifm_sd cb710-mmc via-sdmmc vub300 sdhci-pltfm md_mod dm_mod dm_raid cryptd aes aes_generic aes_x86_64 aes_i586 dm_crypt cbc sha256_generic xts scsi_mod scsi_transport_spi scsi_transport_sas sd_mod sr_mod usb-common usbcore xhci-pci ehci-hcd ehci-pci ohci-hcd uhci-hcd xhci-hcd usb-storage virtio virtio_blk virtio_pci virtio_net virtio_scsi; do
        modprobe $MODULE >> /loadmodules.log 2>&1
        if [ "$?" != "0" ]; then rmmod $MODULE || true; fi
      done
      echo "Done loading initial module '`uname -r`' from initrd. Log is in /loadmodules.log"
      debug
    fi
    rm -rf /lib/modules/*
    mount -nt tmpfs tmpfs -o mode=0755 /m
    cp -a ??* /m 2>/dev/null
    exec switch_root /m linuxrc "$@" # Free initramfs and switch to another root fs
fi

mount -nt proc proc /proc
mount -nt sysfs sysfs /sys
echo 0 >/proc/sys/kernel/printk
mkdir -p /memory/images

#clear
echo "[1m""Starting init script ""[0m"
# Helper Functions:
# Variables: i and m is color code
i=`echo "[1;33m""^ ""[0m"`
m=`echo "[1;33m""->""[0m"`
arch=`uname -m`; [ $arch = x86_64 ] || arch=i486
DELAY=`value delay`; [ $DELAY ] && { echo $i"delaying $DELAY sec (waiting for slow devices to settle up)"; sleep $DELAY; }
USB_DELAY=`value usb_delay` 
OSDIR=`value os`; [ $OSDIR ] || OSDIR="ubuntu"
SGN=`value sgnfile`; [ $SGN ] || SGN=${OSDIR}-$arch.sgn
FROM=`value from`; ISO=`echo $FROM | egrep ".*\.iso( |\$)"`
IP=`value ip | cut -d: -f2`
MOPT=`value mopt`; [ $MOPT ] || MOPT="noatime,nodiratime,suid,dev,exec,async"
# format <file-system-name>:<option-string>. It will be appended to the MOPT
MOPT1=`value mopt1`; [ $MOPT1 ] || MOPT1=""
CHANGES=`value changes`; [ $CHANGES ] || CHANGES=`value c`
RAMSIZE=`value ramsize`; [ $RAMSIZE ] || RAMSIZE=60%
ZRAMSIZE=`value zramsize`; [ $ZRAMSIZE ] || ZRAMSIZE=256M
LOAD=`value load | sed 's/;/|/g'`; [ $LOAD ] || LOAD=""
NOLOAD=`value noload | sed 's/;/|/g'`; [ $NOLOAD ] || NOLOAD=._null
EXTRAMOD=`value extramod | sed 's/;/ /g'`
RAMMOD=`value rammod | sed 's/;/|/g'`
ROOTCOPY=`value rootcopy`
livedbg=/var/log/livedbg
PASSPHRASE=`value pass`; [ "$PASSPHRASE" ] || PASSPHRASE=
PASSPHRASE_FILE=`value passfile`; [ "$PASSPHRASE_FILE" ] || PASSPHRASE_FILE=
# without the /dev/
RAW_DEV=`value raw`; [ "$RAW_DEV" ] || RAW_DEV=`value r`
FACTORYRESET=`value reset`; [ $FACTORYRESET ] || FACTORYRESET=`value factoryreset`; [ $FACTORYRESET ] || FACTORYRESET='0'
# FACTORYRESET values: 1 - reset but keep home, 2 reset with backup - 3 reset everything, no backup, 4 reset mod 999,
# -1 reset base image to .old and keep home
KVER=`uname -r`
KPATH=`value kpath`; [ $KPATH ] || KPATH=
KMOD_DETECTED=
HOSTNAME=`value h`; [ $HOSTNAME ] || HOSTNAME=`value hn`; [ $HOSTNAME ] || HOSTNAME=`value hostname`
# suggest to use started path /_keystore/<luks-header-file> so we have common place to put passphrase and luks header
LUKS_HEAD=`value lh`
UNION_FS_TYPE=`value unionfs`; [ $UNION_FS_TYPE ] || UNION_FS_TYPE='overlay'
CHANGES_MOUNT=/memory/changes
# kexec=/full/path/to/kernel/image to load secondary kernel. Same dir must have initrd.xz
KEXEC=`value kexec`; [ $KEXEC ] || KEXEC=
TMPFS=`value tmpfs`

if [ ! -z "$LUKS_HEAD" ]; then
    CRYPTSETUP_OPT="--header $LUKS_HEAD"
    echo "LUKS_HEAD (lh) supplied. CRYPTSETUP_OPT='$CRYPTSETUP_OPT'. Recommend to use the file from this path /_keystore/<<headerfile>"
    if [ -z "$RAW_DEV" ]; then echo "If you want to use separate LUKS_HEAD you need to supply RAW_DEV using option r=" ; fi
fi

CRYPTSETUP_OPT="$CRYPTSETUP_OPT --allow-discards"

# generate hostname based on motherboard UUID if no hostname is given at all
parse_passphrase() {
    if echo $PASSPHRASE | grep '^#' >/dev/null 2>&1; then
        HASHFUNC=$(echo $PASSPHRASE | cut -f2 -d#)
        PASSPHRASE=$(cat /sys/devices/virtual/dmi/id/product_uuid | $HASHFUNC | cut -f1 -d' ')
    fi
}
# Detect if we have kernel ntfs3 mod
if `grep ntfs3 /proc/filesystems >/dev/null 2>&1`; then
    NTFS_TYPE="ntfs3"
    MOUNT_NTFS_CMD="mount -t ntfs3 -o $MOPT"
else
    NTFS_TYPE="ntfs-3g"
    MOUNT_NTFS_CMD="ntfs-3g -o $MOPT"
fi
# Device Functions:
detect_fs_type() { # where blkid does not understand that file system we need this hack
    #echo "detect_fs_type $1"
    mkdir /tmp/mount_temp >/dev/null 2>&1
    mount $1 /tmp/mount_temp
    if [ $? == 0 ]; then
        fstype=`mount | grep $1 | cut -f5 -d' '`
    else
        fstype=auto
    fi
    echo "$1: TYPE=\"$fstype\""
    umount /tmp/mount_temp
}
fstab() { # make fstab, decrypt module, temp mount kernel and load base modules
# require /tmp/devices with filled with the output of blkid
param nocd && { egrep -v '/dev/sr' /tmp/devices >/tmp/devices1 ; mv /tmp/devices1 /tmp/devices; }
param nohd && { egrep -v '/dev/sr|/dev/loop|/dev/mapper' /tmp/devices >/tmp/devices1 ; mv /tmp/devices1 /tmp/devices; }
if [ ! -z "$TMPFS" ]; then
    TMPFS="tmpfs /tmp tmpfs defaults 0 0"
fi
cat > /etc/fstab << EOF
# Do not edit this file as fstab is recreated automatically during every boot.
# Please use /etc/rc.d/rc.local or sysvinit scripts if you want to mount/unmount
# drive, filesystem or network share.

# System mounts:
proc /proc proc defaults 0 0
sysfs /sys sysfs defaults 0 0
devtmpfs /dev devtmpfs defaults 0 0
devpts /dev/pts devpts rw,mode=0620,gid=5 0 0
$TMPFS
# Device partitions:
EOF
dev=`egrep -v 'TYPE="sw|TYPE="LVM|TYPE=".*_raid_member"' /tmp/devices 2>/dev/null | cut -f 1 -d: | sed 's|/dev/||' | sort | uniq`
for x in $dev; do
  echo "processing dev $x"
  debug
  if blkid /dev/$x 2>/dev/null | cut -d" " -f3- | grep -q LUKS; then
      if `ls /dev/mapper/${x}_DEC >/dev/null 2>&1`; then
          echo "crypt already setup for device $x"
      else
          if blkid /dev/$x 2>/dev/null | grep -q "Linux swap"; then
            swapcrypt.sh $x
            continue
          fi
	  if [ -z "$PASSPHRASE" ]; then echo "$x ..."; PASSPHRASE=$(timeout 30 sh -c 'read -s p && echo $p'); fi
          parse_passphrase; echo $PASSPHRASE | /usr/bin/cryptsetup $CRYPTSETUP_OPT --key-file=- luksOpen /dev/$x ${x}_DEC
          if [ $? != 0 ] && [ ! -z "$PASSPHRASE" ]; then
		echo "Failed, second try .."; PASSPHRASE=$(timeout 30 sh -c 'read -s p && echo $p')
   	  	parse_passphrase; echo $PASSPHRASE | /usr/bin/cryptsetup $CRYPTSETUP_OPT --key-file=- luksOpen /dev/$x ${x}_DEC
          fi
          if [ $? == 0 ]; then
              x="${x}_DEC"; ln -sf /dev/mapper/$x /dev/$x
              fsck_dat /dev/$x
              detect_fs_type /dev/$x >> /tmp/devices
              #blkid /dev/$x >> /tmp/devices
          else
              PASSPHRASE=""; continue
          fi
      fi
  elif [ "/dev/${RAW_DEV}" = "/dev/$x" ]; then
      if `ls /dev/mapper/${x}_DEC >/dev/null 2>&1`; then
          :
      else
          if [ -z "$PASSPHRASE" ]; then echo "$x ..."; PASSPHRASE=$(timeout 30 sh -c 'read -s p && echo $p'); fi
          if [ -z "$LUKS_HEAD" ]; then
            parse_passphrase; echo $PASSPHRASE | /usr/bin/cryptsetup --key-file=- plainOpen /dev/$x ${x}_DEC
          else
            echo -e "/dev/$x => '$LUKS_HEAD' .....\n\n"
            parse_passphrase; echo $PASSPHRASE | /usr/bin/cryptsetup --key-file=- --header=$LUKS_HEAD luksOpen /dev/$x ${x}_DEC
          fi
          if [ $? == 0 ]; then
              x="${x}_DEC"; ln -sf /dev/mapper/$x /dev/$x
              fsck_dat /dev/$x
              detect_fs_type /dev/$x >> /tmp/devices
          else
              PASSPHRASE=""
          fi
      fi
  fi

  fs=`grep -w /dev/$x /tmp/devices | egrep -o ' TYPE=[^ ]+' | cut -d'"' -f2`
  if [ -z "$fs" ]; then
      echo "not be able to detect fs, will skip"; fs=''; continue
  else
      echo "detected fs for $x is '$fs' mopt1 is ${MOPT1}"
  fi
  debug
  mountdir=$(basename $x)
  _MOPT1=$(echo $MOPT1 | egrep -o "${fs}:[^ ]+" | cut -f 2 -d:)
  if [ ! -z "${_MOPT1}" ]; then USE_MOPT="${_MOPT1}"; else USE_MOPT=$MOPT; fi
  if [ "$fs" = "vfat" ] ||  [ "$fs" = "exfat" ]; then
          echo "/dev/$x /mnt/$mountdir $fs ${USE_MOPT},umask=0,utf8 0 0" >>/etc/fstab
  elif [ "$fs" = "iso9660" ]; then
          echo "/dev/$x /mnt/$mountdir $fs ${USE_MOPT},ro 0 0" >>/etc/fstab
  elif $(echo $x | grep mapper >/dev/null 2>&1);then
        #echo "/dev/$x /mnt/$mountdir $fs ${MOPT},x-systemd.device-timeout=1 0 0" >>/etc/fstab
        echo "/dev/$x /mnt/$mountdir $fs ${USE_MOPT} 0 0" >>/etc/fstab
  else
        echo "/dev/$x /mnt/$mountdir $fs ${USE_MOPT} 0 0" >>/etc/fstab
  fi

  if [ -z "$KPATH" ] && [ ! -z "$KEXEC" ]; then KPATH=$(dirname $KEXEC); fi
  echo "done populating /etc/fstab with detected device entries $x"
  debug
  if [ ! -d "/mnt/$mountdir" ]; then
      mkdir "/mnt/$mountdir"
  else
      echo "/mnt/$mountdir already exists, try unmounting"; umount /mnt/$mountdir || true
  fi
  local _x_block_dev=$(echo $x | sed 's/[0-9]\+$//')
  local _x_is_usb=no
  if `ls -lha /sys/block/${_x_block_dev} | grep '/usb[0-9]\+' >/dev/null 2>&1`; then
      _x_is_usb=yes
  else
      _x_is_usb=no
  fi
  if [ "$fs" = "ntfs" ]; then
    echo "detect ntfs going to mount with -o $MOPT"
    $MOUNT_NTFS_CMD /dev/$x /mnt/$mountdir
    if [ $? != 0 ]; then
        echo "mount error"; sed -i "/$x /d" /etc/fstab; rmdir /mnt/$x;
    else
        if [ "${_x_is_usb}" = "yes" ]; then 
            if [ ! -z "$USB_DELAY" ]; then sleep $USB_DELAY; fi
        fi 
    fi
    for _PATH in /mnt/${x}/${FROM}/${OSDIR}/base /mnt/${mountdir}/${FROM} /mnt/${mountdir}/${KPATH}; do
      if [ "$KMOD_DETECTED" == "y" ]; then break; fi
      KMODS=`find ${_PATH}/000-*.[xglz]zm 2>/dev/null`
      if [ -z "$KMODS" ]; then KMODS=`find ${_PATH}/000-*.[xglz]zm.bak 2>/dev/null`; fi
      if [ ! -z "$KMODS" ]; then
        for KMOD in $KMODS; do
          if [ -f "${KMOD}.new" ]; then mv "${KMOD}.new" "${KMOD}"; fi
          mkdir -p /opt/000-kernel >/dev/null 2>&1
          mount -o loop $KMOD /opt/000-kernel  || echo "Can not mount $KMOD"
          if [ -d /opt/000-kernel/lib/modules/$KVER ]; then
            mkdir -p /lib/modules >/dev/null 2>&1
            mount -o bind /opt/000-kernel/lib/modules /lib/modules
            for x in aufs overlay md_mod dm_mod dm_raid dm_crypt cryptd cbc sha256_generic aes aes_generic aes_x86_64 aes_i586 scsi_mod scsi_transport_spi scsi_transport_sas sd_mod sr_mod jfs ext2 ext4 ext3 squashfs isofs virtio virtio_blk virtio_pci virtio_net; do modprobe $x 2>/dev/null; done
            KMOD_DETECTED=y; echo "FOUND $KMOD"; echo "$KMOD" > /tmp/modules; break
          else
            umount /opt/000-kernel
          fi
        done
      fi
    done
  else
    mount -n /mnt/$mountdir 2>/dev/null
    if [ $? != 0 ]; then
       modprobe $fs 2>/dev/null
       mount -n /mnt/$mountdir 2>/dev/null
       if [ $? != 0 ]; then
         sed -i "/$x /d" /etc/fstab; rmdir /mnt/$mountdir
       else
         if [ "${_x_is_usb}" = "yes" ]; then 
             if [ ! -z "$USB_DELAY" ]; then 
                sleep $USB_DELAY
             fi
         fi 
       fi
    else
        if [ "${_x_is_usb}" = "yes" ]; then 
            if [ ! -z "$USB_DELAY" ]; then
                sleep $USB_DELAY
            fi
        fi 
    fi
    for _PATH in /mnt/${mountdir}/${FROM}/${OSDIR}/base /mnt/${mountdir}/${FROM} /mnt/${mountdir}/${KPATH}; do
      if [ "$KMOD_DETECTED" == "y" ]; then break; fi
      KMODS=`find ${_PATH}/000-*.[xglz]zm 2>/dev/null`
      if [ -z "$KMODS" ]; then KMODS=`find ${_PATH}/000-*.[xglz]zm.bak 2>/dev/null`; fi
        if [ ! -z "$KMODS" ]; then
          for KMOD in $KMODS; do
              if [ -f "${KMOD}.new" ]; then mv "${KMOD}.new" "$KMOD"; fi
              mkdir -p /opt/000-kernel >/dev/null 2>&1
              mount -o loop $KMOD /opt/000-kernel || echo "=> Can not mount $KMOD <="
              if [ -d /opt/000-kernel/lib/modules/$KVER ]; then
                mkdir -p /lib/modules >/dev/null 2>&1
                mount -o bind /opt/000-kernel/lib/modules /lib/modules
                for x in aufs overlay md_mod dm_mod dm_raid dm_crypt cryptd cbc sha256_generic aes aes_generic aes_x86_64 aes_i586 scsi_mod scsi_transport_spi scsi_transport_sas sd_mod sr_mod jfs ext2 ext4 ext3 squashfs isofs virtio virtio_blk virtio_pci virtio_net; do modprobe $x 2>/dev/null; done
                KMOD_DETECTED=y; echo "FOUND $KMOD"; echo "$KMOD" > /tmp/modules; break
              else
                umount /opt/000-kernel; KMOD=
              fi
          done
      fi
    done
  fi
done

if [ -z "`egrep -o " noswap( |\$)" /etc/cmdline`" -a -e /tmp/devices ]; then
    echo -e "\n# Swap partitions:" >>/etc/fstab
    for x in `grep 'TYPE="swap"' /tmp/devices | cut -d: -f1`; do echo "$x none swap sw,pri=1 0 0" >>/etc/fstab; done
  grep -v 'LUKS"' /etc/fstab > /etc/fstab.new; mv /etc/fstab.new /etc/fstab
fi } # end fstab

mount_device() {
fs=`blkid /dev/$1 | egrep -o ' TYPE=[^ ]+' | cut -d'"' -f2`
if [ -z "$fs" ]; then fs=`detect_fs_type /dev/$1 | egrep -o ' TYPE=[^ ]+' | cut -d'"' -f2`; fi
if [ "$fs" ]; then
    mountdir=$(basename $x)
    mkdir "/mnt/$mountdir"
    if [ "$fs" = "vfat" ]; then
        mount -n /dev/$1 /mnt/$mountdir -o $MOPT,umask=0,utf8 2>/dev/null || rmdir /mnt/$mountdir
    elif [ "$fs" = "ntfs" ]; then
        $MOUNT_NTFS_CMD /dev/$1 /mnt/${mountdir} 2>/dev/null || rmdir /mnt/${mountdir}
    else
        mount -n /dev/$1 /mnt/${mountdir} -o $MOPT 2>/dev/null || { modprobe $fs 2>/dev/null && mount -n /dev/$1 /mnt/${mountdir} -o $MOPT || rmdir /mnt/${mountdir}; }
    fi
fi }
# $1 is the operator (-f -e -d). $2 is the file/folder. Olnly search started
# from /mnt and one dir level
search() { FND=n; for x in `ls /mnt`; do
[ $1 "/mnt/$x/$2" ] && { DEV=$x; FND=y; break; }; done
[ $FND = y ]; }
lazy() { SLEEP=6; while [ $SLEEP -gt 0 ] && [ ! "$FND" = "y" ]; do nap; let SLEEP=SLEEP-1; fstab; search $*; done }
locate() { # locate <-e|-r|-d|-f> PATH ; See the option will be passed to function search above.
# return: set the var DEV, LPTH for the caller to use and return exit code 0 for success otherwise
  LPATH=`echo $2 | cut -b-5 | sed s@/dev@/mnt@`
  if [ "$LPATH" = "/mnt/" ]; then # $2 started with /dev/<dev>
    echo "Detect device path /dev/XXX. will try to setup devices"
    DEV=`echo $2 | cut -d/ -f3`; LPTH=`echo $2 | cut -d/ -f4-`; SLEEP=6
    while [ $SLEEP -gt 0 -a ! -b /dev/$DEV ]; do nap; let SLEEP=SLEEP-1; fstab; done # waiting for device to comeup
    [ -d "/mnt/$DEV" ] || mount_device $DEV
    if [ "$3" = "create" ]; then mkdir -p "/mnt/$DEV/$LPTH"; fi
    [ $1 /mnt/$DEV/$LPTH ]
  elif [ "$LPATH" = "UUID:" -o "$LPATH" = "LABEL" ]; then
    echo "Detect UUID: or LABEL. will try to setup devices"
    ID=`echo $2 | cut -d: -f2 | cut -d/ -f1`; LPTH=`echo $2 | cut -d/ -f2-`; DEV=`blkid | grep $ID | cut -d: -f1 | cut -d/ -f3`; SLEEP=6
    while [ $SLEEP -gt 0 -a "$DEV" = "" ]; do nap; let SLEEP=SLEEP-1; fstab; DEV=`blkid | grep $ID | cut -d: -f1 | cut -d/ -f3`; done
    [ -d /mnt/$DEV ] || mount_device $DEV
    if [ "$3" = "create" ]; then mkdir -p "/mnt/$DEV/$LPTH"; fi
    [ $1 /mnt/$DEV/$LPTH ]
  elif [ "$LPATH" = "mkdir" -o "$LPATH" = "make:" ]; then #detect bigest size available and create changes dir on it
    LPTH=`echo $2 | cut -d: -f2-`; search $* || lazy $* || {
    df -h > /tmp/fssize; BIGEST_SIZE=`cat /tmp/fssize | cut -dG -f3 | sed 's/ \+//g' | sort -n | tail -n 1`
    DEV=`grep $BIGEST_SIZE /tmp/fssize | cut -f5 -d/`; rm -f /tmp/fssize; mkdir -p "/mnt/$DEV/$LPTH"; [ $? = 0 ]
    }
  else
    echo "Direct calling search"
    LPTH=$2; search $* # || lazy $*
  fi
} # end locate

# Other functions:
nap() { echo -en $i"device not ready yet? delaying [1;33m$SLEEP[0m seconds \r"; sleep 1; }
fail() { echo -e $i"couldn't find $1. Correct your cheatcodes if needed.\n  Press 'Ctrl + d' to continue booting after debugging using the shell"; /bin/sh; }
fail_chn() { mount -nt tmpfs -o size=$RAMSIZE tmpfs $CHANGES_MOUNT; CHANGES=memory; CHNDEV=memory; touch /etc/nochanges; }
draw() { echo "[1;33m""---------------------------------------------------------""[0m"; }
fsck_dat() { echo $i"checking $1 for errors"

if ! param fsck; then return; fi

fs=`blkid $1 | egrep -o ' TYPE=[^ ]+' | cut -b8-10`
if [ -z "$fs" ]; then fs=`detect_fs_type $1 | egrep -o ' TYPE=[^ ]+' | cut -d'"' -f2`; fi
if [ "$fs" = "xfs" ]; then
    echo $i"detected xfs - not performing fsck at mount time"
elif [ "$fs" = "ext" ]; then
    draw; e2fsck -C 0 -p $1; wait; draw
elif [ "$fs" = "rei" ]; then
    draw; reiserfsck -p $1; wait; draw
elif [ "$fs" = "f2f" ]; then
    draw; fsck.f2fs $1; wait; draw
else
    echo $i"detected unsupported fs - skipping fsck"
fi } # end fsck_dat

cpmod() { NUM=`grep -c '.' $1`
for x in `cat $1`; do
    echo -en "[1;33m""  ($NUM modules left)  \r""[0m"; let NUM=NUM-1; NAME=`basename $x`
    if [ -f "${x}.new" ]; then cp ${x}.new /memory/copy2ram/${x} 2>/dev/null; mv ${x}.new ${x}; else cp $x /memory/copy2ram 2>/dev/null; fi
    if [ $? = 0 ]; then
    sed -i s@^.*/$NAME@/memory/copy2ram/$NAME@ /tmp/modules
    else
    rm /memory/copy2ram/$NAME; echo -e $i"[1;36m""Not enough memory to copy $NAME""[0m"; echo -e $i"[1;36m""Other modules will be skipped.""[0m"
    find /memory/copy2ram -name "*.[xglz]zm" | sort >> /tmp/modules
    break
    fi
done
echo -en "                       \r"; } # end cpmod

dirname() {
    _n=$(basename "$1")
    echo "$1" | sed "s@/${_n}@@"
}
generate_devices() {
echo "Detect block devices, create /etc/fstab and mount devices ..."
echo "List devices: "
find /dev/nvme* 
find /dev/sd* 
find /dev/mmcblk?p? 
find /dev/vd* 
find /dev/mapper/* 
find /dev/sr*
blkid /dev/nvme* /dev/sd* /dev/mmcblk?p? /dev/vd* /dev/mapper/* /dev/sr* | grep -v /dev/loop | grep -v BitLocker | grep TYPE > /tmp/devices
if [ ! -z "$RAW_DEV" ]; then blkid "/dev/$RAW_DEV" >> /tmp/devices; fi
#blkid /dev/nvme* | grep -v 'EFI system partition' | grep -v 'BitLocker' | grep ' TYPE=' >> /tmp/devices
#for listd in '/dev/sd??' '/dev/mmcblk?p?' '/dev/vd??'; do
#   for d in $listd; do # add auto to some fs that blkid not know about
#       o=`blkid $d`
#       if [ "$?" != '0' ]; then echo "${d}: TYPE=\"auto\"" >> /tmp/devices; fi
#   done
#done
}

echo "Start porteus init script - modified by stevek version v1.10"
# Make all drivers available: stevek move it first so we have module
echo "mount /dev ..."
debug
mount -nt devtmpfs none /dev
mkdir -p /run/cryptsetup 
if [ ! -z "$USB_DELAY" ]; then sleep $USB_DELAY ; fi # devices settle down
echo -e "done\ngenerate hostname ...\n"
debug
echo -e "generate_devices..."
generate_devices
echo -e "done generate_devices"
debug
if [ ! -z "${PASSPHRASE_FILE}" ]; then
    mkdir -p /_keystore
    if `echo "${PASSPHRASE_FILE}" | grep ':' >/dev/null 2>&1`; then
        _PASSPHRASE_DEV=$(echo ${PASSPHRASE_FILE} | egrep -o '^[^:]+')
        PASSPHRASE_FILE=$(echo ${PASSPHRASE_FILE} | egrep -o '[^:]+$')
    elif `echo "${PASSPHRASE_FILE}" | grep '/' >/dev/null 2>&1`; then
        _PASSPHRASE_DEV=$(echo ${PASSPHRASE_FILE} | egrep -o '^[^/]+')
        PASSPHRASE_FILE=$(echo ${PASSPHRASE_FILE} | cut -f 2- -d/)
    else
        echo "[WARN] PASSPHRASE_FILE (opt passfile) supplied but haing no device separator. The format is <devicename>[:/]<path-to-file> "
        _PASSPHRASE_DEV=""
    fi
    if [ ! -z "${_PASSPHRASE_DEV}" ] && [ -b /dev/${_PASSPHRASE_DEV} ]; then
        mount /dev/${_PASSPHRASE_DEV} /_keystore
        PASSPHRASE=$(cat /_keystore/${PASSPHRASE_FILE})
    else
        [ ! -z "${_PASSPHRASE_DEV}" ] && PASSPHRASE_FILE="${_PASSPHRASE_DEV}/$PASSPHRASE_FILE"
        _securedev=`egrep -v 'TYPE="sw|TYPE="LVM|TYPE=".*_raid_member"' /tmp/devices 2>/dev/null | cut -f 1 -d: | sort | uniq`
        for block_dev in $_securedev; do
            echo "trying to search for ${PASSPHRASE_FILE} in dev $block_dev ..."
            mount $block_dev /_keystore
            if [ -f /_keystore/${PASSPHRASE_FILE} ]; then
                PASSPHRASE=$(cat /_keystore/${PASSPHRASE_FILE})
                debug
                break
            else
                umount /_keystore
            fi
        done
    fi
    if [ -z "$PASSPHRASE" ]; then
        echo "[WARN] PASSPHRASE_FILE is supplied but can not parse into PASSPHRASE"
    fi
else
    parse_passphrase
fi
echo -e "done parse passphrase"
debug
[ -z "$HOSTNAME" ] && HOSTNAME=$(cat /sys/class/dmi/id/product_name | cut -f1 -d-)

echo ${HOSTNAME} > /proc/sys/kernel/hostname

if param pause; then
    echo "Start shell ..."
    ls /dev/sd* /dev/nvm* 2>/dev/null
    /bin/sh
fi
fstab
# echo "Re-generate again as fstab will mount kernel module and load extra devices in."
# debug
# generate_devices
echo -e "done\ncheck KEXEC ...\n"
debug
rm -f /etc/mtab ; ln -sf /proc/mounts /etc/mtab
if [ ! -z "$KEXEC" ]; then
    if [ ! -z "$FROM" ]; then
        locate -e $FROM/${OSDIR}/$SGN
        KERNEL="/mnt/$DEV/$KEXEC"
    else
        KDIR=$(dirname ${KEXEC}); KNAME=$(basename ${KEXEC})
        KERNEL=$(find /mnt/*/${KDIR} -name $KNAME 2>/dev/null|tail -n1)
    fi
    if [ -f "$KERNEL" ]; then
        INITRD="$(dirname $KERNEL)/${KNAME}-initrd.xz"
    fi
    echo "$KERNEL $INITRD"
    if [ -f "$KERNEL" ] && [ -f "$INITRD" ]; then
        cmdline=$(cat /proc/cmdline|sed 's/ kexec=[^ ]\+ / /'|sed 's/BOOT_IMAGE=[^ ]* //g')
        echo "$cmdline"
        echo "Found kexec kernel and initrd, prepare to load and boot the new kernel"
        /usr/bin/kexec -l $KERNEL --initrd $INITRD --command-line="$cmdline"
        debug
        echo done loading kexec. some reason kexec has error status but it still works thus need echo here
        if [ $? = 0 ]; then
            umount /dev/loop*; umount /mnt/*
            sync
            echo exec kernel now
            /usr/bin/kexec -e
        else
            echo some error with kexec. hit enter to continue old kernel; read _junk
        fi
    fi
fi

echo -e "done\n$i searching for $SGN file ...\n"
debug
if [ "$IP" ]; then BOOTDEV=network; SGNDEV=/mnt/nfs
    for x in `lspci | grep 0200: | cut -d: -f3-4 | sed s/:/.*/g | tr a-z A-Z`; do modprobe `grep $x /lib/modules/$(uname -r)/modules.alias | tail -n1 | rev | cut -d" " -f1 | rev` 2>/dev/null; done
    ls /sys/class/net | grep -q eth || { for x in `find /lib/modules/$(uname -r)/kernel/drivers/net -name "*.ko" | sed 's/.ko//g'`; do modprobe `basename $x` 2>/dev/null; ls /sys/class/net | grep -q eth && break || modprobe -r `basename $x` 2>/dev/null; done; }
    mkdir -p /mnt/nfs/porteus /mnt/nfs/storage; udhcpc; modprobe nfsv4; mount -t nfs4 $IP:/srv/pxe/porteus /mnt/nfs/porteus -o ro,nolock 2>/dev/null || { modprobe nfsv3; mount -t nfs $IP:/srv/pxe/porteus /mnt/nfs/porteus -o ro,nolock 2>/dev/null; }
    MAC=`ifconfig | grep eth0 | cut -d: -f5-7 | sed s/://g | cut -d" " -f1`
    if [ "$CHANGES" = /srv/pxe/storage ]; then
    if lsmod | grep -q nfsv3; then
        mount -t nfs $IP:/srv/pxe/storage /mnt/nfs/storage -o rw,nolock 2>/dev/null && { mkdir -p /mnt/nfs/storage/client-$MAC/changes/home; CHANGES="/storage/client-$MAC"; }
    else
        mount -t nfs4 $IP:/srv/pxe/storage /mnt/nfs/storage -o rw,nolock 2>/dev/null && { mkdir -p /mnt/nfs/storage/client-$MAC/changes/home; CHANGES="/storage/client-$MAC"; }
    fi
    fi
elif [ "$ISO" ]; then SGNDEV=/mnt/isoloop
    locate -e $FROM && { BOOTDEV=/mnt/$DEV; mkdir /mnt/isoloop; mount -o loop /mnt/$DEV/$LPTH /mnt/isoloop; }
else
    if [ "$FROM" ]; then
        locate -e $FROM/${OSDIR}/$SGN
        if [ $? = 0 ]; then
            DIR=`echo $LPTH | rev | cut -d/ -f3- | rev`; [ $DIR ] && OSDIR=$DIR/${OSDIR}
        else
            echo $i"from= cheatcode is incorrect, I am going to search through all devices"
            debug; search -e ${OSDIR}/$SGN
        fi
    else
        search -e ${OSDIR}/$SGN || lazy -e ${OSDIR}/$SGN
    fi
    SGNDEV=/mnt/$DEV
fi
[ -e $SGNDEV/$OSDIR/$SGN ] && PTH=$SGNDEV/$OSDIR || . fatal
PTH=`echo $PTH | sed 's|//|/|'`
echo $i"using data from $PTH"
echo  $PTH > /etc/homedrv
echo -e $i"done.\nCreate symlinks used often by porteus scripts ...\n"
[ -d $PTH/modules ] && ln -sf $PTH/modules  /porteus/modules
[ -d $PTH/optional ] && ln -sf $PTH/optional /porteus/optional
CURRENT_IMAGE_FILE=$(find $PTH/base -name "001-*-${arch}.[xglz]zm" 2>/dev/null | egrep -v ".old" | tail -n1 )
echo -e $i"use current porteus base image $CURRENT_IMAGE_FILE"

echo -e $i"done.\nCheck update image porteus-update-$(value os)-${arch}.squashfs ...\n"
debug
if [ "$FACTORYRESET" = "-1" ] && [ -f "${CURRENT_IMAGE_FILE}.old" ]; then
    echo "FACTORYRESET is -1 and ${CURRENT_IMAGE_FILE}.old exists. Will base image reset to that file "
    rm "${CURRENT_IMAGE_FILE}.new" || true
    mv "${CURRENT_IMAGE_FILE}.old" "${CURRENT_IMAGE_FILE}"
    FACTORYRESET='1'
fi
if [ -f "${CURRENT_IMAGE_FILE}.new" ]; then
  echo "Found ${CURRENT_IMAGE_FILE}.new"
  if [ "$FACTORYRESET" = "0" ]; then echo "Set FACTORYRESET=1"; FACTORYRESET='1'; fi
  echo "Skip UPDATE_IMAGE_FILE"; UPDATE_IMAGE_FILE=""
else
  UPDATE_IMAGE_FILE=$(find /mnt/*/ -maxdepth 1 -name "porteus-update-$(value os)-${arch}.squashfs")
fi
if [ ! -z "$UPDATE_IMAGE_FILE" ]; then
  echo "Found UPDATE_IMAGE_FILE $UPDATE_IMAGE_FILE"
  if [ $(stat -c %Y $UPDATE_IMAGE_FILE) -gt $(stat -c %Y $CURRENT_IMAGE_FILE) ]; then
    echo -e $i"move $UPDATE_IMAGE_FILE to $CURRENT_IMAGE_FILE"
    cp -a $UPDATE_IMAGE_FILE $CURRENT_IMAGE_FILE
    mv $UPDATE_IMAGE_FILE ${UPDATE_IMAGE_FILE}.old
  else
    echo "current image newer or equal than update image."
  fi
else
  echo "could not find update image file '$UPDATE_IMAGE_FILE'"
fi

echo -e $i"done.\nSetup changes ...\n"
echo "INFO RAW_DEV: $RAW_DEV - CHANGES: $CHANGES"
debug
if [ "$CHANGES" ]; then
# CHANGES_MOUNT - final directory used for overlay, under that there is overlay
# rootdir/workdir. Default /memory/changes
# CHANGES_MOUNT_SRC - base directory to mound bind to CHANGES_MOUNT. Under that always has dir 'changes' 'changes.backup' - the changes dir will be mount bind to CHANGES_MOUNT.
    echo $i"setting up directory for changes"
    CHNEXIT=`echo $CHANGES | cut -d: -f1`; [ $CHNEXIT = EXIT ] && CHANGES=`echo $CHANGES | cut -d: -f2-`
# Test if it is in the format <image-file>/dir
    IMG_FILE=`echo $CHANGES | cut -d/ -f1`; CPATH=`echo $CHANGES | cut -d/ -f2-`
    echo "IMG_FILE=$IMG_FILE CPATH=$CPATH"
    debug
    locate -d $CHANGES create #If the changes starts with device or UUID/LABEL path then we create it if not exists
    if [ ! $? -eq 0 ]; then
        echo "locate with create failed. Try to local as an image file"
        locate -f $IMG_FILE
        if [ $? -eq 0 ]; then
            CIMAGE_FILE=/mnt/$DEV/$LPTH
            IMAGE_MOUNT_DIR=/memory/images/${IMG_FILE}; mkdir -p $IMAGE_MOUNT_DIR >/dev/null 2>&1
            CHANGES_DEV=$DEV
            if [ ! "$CPATH" == "$IMG_FILE" ]; then
                CPATH_EXIST=yes; CHANGES_MOUNT_SRC=$IMAGE_MOUNT_DIR/$CPATH;
            else
                CHANGES_MOUNT_SRC=$IMAGE_MOUNT_DIR
            fi
            if blkid $CIMAGE_FILE 2>/dev/null | cut -d" " -f3- | grep -q LUKS; then
              LODEV=$(losetup -f); losetup $LODEV $CIMAGE_FILE
              echo $i"sha512 $CIMAGE_FILE"
              if [ -z "$PASSPHRASE" ]; then echo "$CIMAGE_FILE ..."; PASSPHRASE=$(timeout 30 sh -c 'read -s p && echo $p'); fi
              parse_passphrase; echo $PASSPHRASE | /usr/bin/cryptsetup $CRYPTSETUP_OPT --key-file=- luksOpen $LODEV ${IMG_FILE}.$$
              if [ $? != 0 ] && [ ! -z "$PASSPHRASE" ]; then
		echo "Failed, second try .."
		PASSPHRASE=$(timeout 30 sh -c 'read -s p && echo $p')
		parse_passphrase; echo $PASSPHRASE | /usr/bin/cryptsetup $CRYPTSETUP_OPT --key-file=- luksOpen $LODEV ${IMG_FILE}.$$
	      fi
              fsck_dat /dev/mapper/${IMG_FILE}.$$
              mount /dev/mapper/${IMG_FILE}.$$ $IMAGE_MOUNT_DIR 2>/dev/null && touch $IMAGE_MOUNT_DIR/._test1 2>/dev/null
            elif [ ! -z "$RAW_DEV" ]; then
              _tmp=$(echo $CHANGES | cut -f1 -d/)
              if [ "$RAW_DEV" = "${_tmp}" ]; then
                LODEV=$(losetup -f); losetup $LODEV $CIMAGE_FILE
                if [ -z "$PASSPHRASE" ]; then echo "$CIMAGE_FILE ..."; PASSPHRASE=$(timeout 30 sh -c 'read -s p && echo $p'); fi
                if [ -z "$LUKS_HEAD" ]; then
                    parse_passphrase; echo $PASSPHRASE | /usr/bin/cryptsetup --key-file=- plainOpen $LODEV ${IMG_FILE}.$$
                else
                    echo "$RAW_DEV $LUKS_HEAD ....."
                    #sh
                    parse_passphrase; echo $PASSPHRASE | /usr/bin/cryptsetup --key-file=- --header=$LUKS_HEAD luksOpen $LODEV ${IMG_FILE}.$$
                fi
                fsck_dat /dev/mapper/${IMG_FILE}.$$
                mount /dev/mapper/${IMG_FILE}.$$ $IMAGE_MOUNT_DIR 2>/dev/null && touch $IMAGE_MOUNT_DIR/._test1 2>/dev/null
              fi
            else
              fsck_dat /mnt/$DEV/$LPTH
              mount -o loop $CIMAGE_FILE $IMAGE_MOUNT_DIR 2>/dev/null && touch $IMAGE_MOUNT_DIR/._test1 2>/dev/null
            fi
        else
            echo "can not locate as a image file"
        fi
    else
        CHANGES_MOUNT_SRC=/mnt/$DEV/$LPTH
# This does not work with overlayfs,  upper fs does not support tmpfile.
# upper fs does not support RENAME_WHITEOUT. Looks like FUSE does not support it yet? Same for gocryptfs and encfs
        if [ -d ${CHANGES_MOUNT_SRC}.gocryptfs ]; then
            /usr/bin/gocryptfs ${CHANGES_MOUNT_SRC}.gocryptfs ${CHANGES_MOUNT_SRC}
            if [ $? -eq 0 ]; then
                echo "error, spawn shell to recover manually. Press Ctrl + d to continue"
                /bin/sh
            fi
        fi
        CHANGES_DEV=$DEV
        echo "locate or create success CHANGES_MOUNT_SRC=$CHANGES_MOUNT_SRC CHANGES_DEV=$CHANGES_DEV"
    fi
    if [ ! -z "${CHANGES_MOUNT_SRC}" ]; then
# factory reset handling and mount bind to $CHANGES_MOUNT
        if [ "$FACTORYRESET" == '3' ]; then
          rm -rf ${CHANGES_MOUNT_SRC}/changes
        elif [ "$FACTORYRESET" == '1' ] || [ "$FACTORYRESET" == 'keephome' ];  then
          rm -rf ${CHANGES_MOUNT_SRC}/changes.backup
          mv ${CHANGES_MOUNT_SRC}/changes ${CHANGES_MOUNT_SRC}/changes.backup
          mkdir -p "${CHANGES_MOUNT_SRC}/changes/rootdir"
          debug
	      mv ${CHANGES_MOUNT_SRC}/changes.backup/rootdir/home ${CHANGES_MOUNT_SRC}/changes/rootdir/
        elif [ "$FACTORYRESET" == '2' ] || [ "$FACTORYRESET" == 'backup' ];  then
            rm -rf ${CHANGES_MOUNT_SRC}/changes.backup
            mv ${CHANGES_MOUNT_SRC}/changes ${CHANGES_MOUNT_SRC}/changes.backup
        fi
        echo "CHANGES_MOUNT_SRC: $CHANGES_MOUNT_SRC - IMAGE_MOUNT_DIR: $IMAGE_MOUNT_DIR"
        mkdir -p "${CHANGES_MOUNT_SRC}/changes"
        mount -o bind ${CHANGES_MOUNT_SRC}/changes $CHANGES_MOUNT
        touch ${CHANGES_MOUNT}/._test1
        debug
        if [ -f "${CHANGES_MOUNT}/._test1" ]; then
            echo $i"testing filesystem on "$CHANGES" for posix compatibility"
            ln -s ${CHANGES_MOUNT_SRC}/changes/._test1 ${CHANGES_MOUNT_SRC}/changes/._test2 && chmod +x ${CHANGES_MOUNT_SRC}/changes/._test1 && [ -x ${CHANGES_MOUNT_SRC}/changes/._test1 ] && chmod -x ${CHANGES_MOUNT_SRC}/changes/._test1 && [ ! -x ${CHANGES_MOUNT_SRC}/changes/._test1 ] && rm -f ${CHANGES_MOUNT_SRC}/changes/._test1 ${CHANGES_MOUNT_SRC}/changes/._test2
            if [ ! $? = 0 ]; then
                rm -f ${CHANGES_MOUNT_SRC}/changes/._test1 ${CHANGES_MOUNT_SRC}/changes/._test2; umount $CHANGES_MOUNT
                echo && echo -e "[1;33m""A Windows filesystem (FAT, NTFS) or other non-posix compatible filesystem\nhas been detected on $CHANGES.\nYour changes cannot be saved directly to the specified storage media with this\nsetup. Please use the '[1;36mPorteus save file manager[1;33m' to create a .dat container\nand use it for saving your changes after your next reboot.""[0m"
                echo "press enter to continue in '[1;36mAlways Fresh[0m' mode for this session"
                read; rmdir /mnt/$DEV/$LPTH/changes; fail_chn
            else
                echo $i"filesystem is posix compatible"; CHNDEV=/mnt/$DEV
                rmdir ${CHANGES_MOUNT_SRC}/changes/rootdir/mnt/* 2>/dev/null
                rm -f ${CHANGES_MOUNT_SRC}/changes/rootdir/var/lock/subsys/* /var/run/laptop-mode-tools/*
                for x in `find ${CHANGES_MOUNT_SRC}/changes/rootdir/var/run -name "*pid" 2>/dev/null`; do rm $x; done
                echo make symlink portdata for the app to know a fixed name to use non overlayfs file like docker
            fi
            echo "Success setup changes on device $DEV"
            PORTDATA_DEV="$DEV"
            debug
        else
            echo $i"changes not writable, using memory instead"; umount $CHANGES_MOUNT 2>/dev/null; read; fail_chn
            debug
        fi
    else
        fail $CHANGES; echo "CHANGES_MOUNT_SRC is empty"; fail_chn
    fi
else
     echo $i"changes cheatcode not found, using memory only"; fail_chn
fi
mkdir -p ${CHANGES_MOUNT}/mnt/live
echo -e "done setup changes\nSetup overlayfs ...\n"

echo -e "\nLoad specific settings for a hostname. The file name is 9XX-${HOSTNAME}-*.sqs ...\n"
debug
if [ -f "$CHANGES_MOUNT_SRC/${HOSTNAME}.init.sh" ]; then
    echo "Source file $CHANGES_MOUNT_SRC/${HOSTNAME}.init.sh found. Source it now..."
    . $CHANGES_MOUNT_SRC/${HOSTNAME}.init.sh
fi

if [ "$FACTORYRESET" == '4' ] || [ "$FACTORYRESET" == 'reset_999' ];  then
    rm -f $PTH/base/[9][0-9][0-9]-${HOSTNAME}*.sqs ${CHANGES_MOUNT_SRC}/[9][0-9][0-9]-${HOSTNAME}*.sqs $PTH/../share/[9][0-9][0-9]-${HOSTNAME}*.sqs || true
fi

find $PTH/base $PTH/modules -name "*.[xglz]zm" 2>/dev/null | egrep -v "$NOLOAD" | sort >> /tmp/modules
find $PTH/../share -name "[0-9][0-9][0-9]-*-${arch}.[xglz]zm" 2>/dev/null | egrep -v "$NOLOAD" | sort >> /tmp/modules
find $PTH/../share -name "[0-9][0-9][1-9]-*-noarch.[xglz]zm" 2>/dev/null | egrep -v "$NOLOAD" | sort >> /tmp/modules
find $PTH/../share -name "[0-9][0-9][0-9]-${HOSTNAME}-*.[xglz]zm" 2>/dev/null | egrep -v "$NOLOAD" | sort >> /tmp/modules

# hostname specific mod must start with 9xx-<HOSTNAME>*.sqs
if [ ! -z "$HOSTNAME" ]; then
    CHANGE_MOD=$(ls ${CHANGES_MOUNT_SRC}/[9][0-9][0-9]-${HOSTNAME}*.sqs)
    if [ -z "${CHANGE_MOD}" ]; then
        find $PTH/base $PTH/modules -name "[9][0-9][0-9]-${HOSTNAME}*.sqs" 2>/dev/null | egrep -v "$NOLOAD" | sort >>/tmp/modules
    else
        echo "${CHANGE_MOD}" | egrep -v "$NOLOAD" | sort >>/tmp/modules
    fi
    if [ -f "$CHANGES_MOUNT_SRC/${HOSTNAME}.fstab" ]; then cat $CHANGES_MOUNT_SRC/${HOSTNAME}.fstab >> /etc/fstab; fi
    if [ -f "$PTH/../share/${HOSTNAME}.fstab" ]; then cat $PTH/../share/${HOSTNAME}.fstab >> /etc/fstab; fi
fi

if [ -z "$LOAD" ]; then
  LOAD="199"
  echo "Load module $PTH/*/${LOAD}*.[xglz]zm"
  ls $PTH/*/${LOAD}*.[xglz]zm | tail -n1 >> /tmp/modules
else
  ls $LOAD | tail -n1 >> /tmp/modules
fi

echo "done loading host specific modules"
debug

if param vga_detect; then
    echo $i"detecting GPU"
    debug
    lspci >/tmp/lspci; nv=`grep "0300: 10de:" /tmp/lspci | cut -d":" -f4`; amd=`grep "0300: 1002:" /tmp/lspci | cut -d":" -f4`
    if [ "$nv" ]; then
    echo $i"$nv chipset found, checking which nVidia driver supports it"
    cd /usr/share/pciids/nVidia; NV=`grep $nv * | cut -d: -f1`; cd /
    if [ "$NV" ]; then
        echo $i"nVidia-$NV.xx driver will be activated -"
        echo $i"if present in $PTH/optional folder"
        find $PTH/optional -name "nVidia-$NV*" 2>/dev/null >>/tmp/modules
    else
        echo $i"latest nVidia driver will be activated -"
        echo $i"if present in $PTH/optional folder"
        find $PTH/optional -name "nVidia-*" 2>/dev/null | egrep -v '96.43.|173.14.|304.' >>/tmp/modules
    fi
    elif [ "$amd" ]; then
    echo $i"checking if $amd GPU belongs to 'Radeon HD' series"
    cd /usr/share/pciids/AMD; HD=`grep $amd * | cut -d: -f1`; cd /
    if [ "$HD" ]; then
            echo $i"AMD proprietary driver will be activated -"
            echo $i"if present in $PTH/optional folder"
            find $PTH/optional -name "$HD-1*" 2>/dev/null >>/tmp/modules
        else
            echo $i"$amd GPU is not supported by amd-catalyst driver - refusing activation"
        fi
    else
        echo $i"could not find any nVidia/AMD GPU on this PC"
    fi
fi

if param baseonly; then
    egrep '^000-' /tmp/modules > /tmp/mod
    grep "${OSDIR}/base/0" /tmp/modules >> /tmp/mod
    mv /tmp/mod /tmp/modules
else
    if [ "$EXTRAMOD" ]; then
    for folder in $EXTRAMOD; do
        echo $i"searching for additional modules in $folder"
        locate -d $folder && { find /mnt/$DEV/$LPTH -name "*.[xglz]zm" 2>/dev/null | egrep -v "$NOLOAD" | sort >>/tmp/modules; } || fail $folder
    done
    fi
fi

# Copy data to RAM:
if param copy2ram; then
    echo $i"copying data to RAM, this may take some time..."
    [ $RAMMOD ] && { egrep "$RAMMOD" /tmp/modules > /tmp/rammod; cpmod /tmp/rammod; } || cpmod /tmp/modules
fi
echo -e "Populate overlay with modules. If there is a .new file then use it if possible\n"
debug
umount /lib/modules 2>/dev/null; umount /opt/000-kernel 2>/dev/null

if ! grep $UNION_FS_TYPE /proc/filesystems >/dev/null 2>&1; then echo "UNION_FS_TYPE $UNION_FS_TYPE is not supported in kernel. "; debug; fi

KERNEL_MOD_DETECTED='no'
for x in `cat /tmp/modules`; do
    if [ -L "$x" ]; then
        echo "$x is symlink, trying to resolve to real path"; x=$(readlink -f $x)
        if [ ! -f "$x" ]; then echo "File $x does not exist, skipping"; continue; fi
    fi
    if [ -f "${x}.new" ]; then
        if [ "$FACTORYRESET" != '3' ]; then mv $x ${x}.old; fi
        mv ${x}.new $x
    fi # will fail from the cdrom but does not matter
    NAME=`basename $x`; mkdir "/memory/images/$NAME"; LODEV=$(losetup -f); losetup $LODEV $x
    if blkid $LODEV 2>/dev/null | cut -d" " -f3- | grep -q LUKS; then
       if [ ! -f "$PASSPHRASE" ]; then echo "$LODEV ..."; PASSPHRASE=$(timeout 30 sh -c 'read -s p && echo $p'); parse_passphrase; echo $PASSPHRASE > $PASSPHRASE; fi
       cat $PASSPHRASE | /usr/bin/cryptsetup $CRYPTSETUP_OPT --key-file=- luksOpen $LODEV ${NAME}_DEC
       if [ $? != 0 ] && [ ! -z "$PASSPHRASE" ]; then echo "Failed, second try .."; PASSPHRASE=$(timeout 30 sh -c 'read -s p && echo $p'); parse_passphrase; echo $PASSPHRASE > $PASSPHRASE; cat $PASSPHRASE | /usr/bin/cryptsetup $CRYPTSETUP_OPT --key-file=- luksOpen $LODEV ${NAME}_DEC; fi
       mount /dev/mapper/${NAME}_DEC /memory/images/$NAME
    else
       _MOUNT_MOD=1 # only mount current kernel ver
       echo $NAME | egrep '^000-' >/dev/null 2>&1
       if [ "$?" == "0" ]; then
           echo $NAME | grep "$KVER"
           if [ "$?" != "0" ]; then
               _MOUNT_MOD=0; losetup -d $LODEV
           else
               KERNEL_MOD_DETECTED="y"
               KERNEL_MOD_MOUNT_PATH="/memory/images/${NAME}/lib/modules/${KVER}"
           fi
       fi
       if [ "$_MOUNT_MOD" == "1" ]; then
           mount $LODEV /memory/images/$NAME 2>/dev/null
       fi
    fi
    if [ $? -eq 0 ]; then
      echo "  $m  $NAME"
      if [ "$KERNEL_MOD_DETECTED" = "y" ]; then
          # Kernel setup at last to avoid it being hidden by the other modules in case of symlink
          KERNEL_MOD_DETECTED='n' # Set it back to allow other module as normal and then bypass the rest
          continue
      fi
      if [ "$UNION_FS_TYPE" = 'aufs' ]; then
          LOWERDIR="/memory/images/${NAME}=ro:${LOWERDIR}"
      else
          LOWERDIR="/memory/images/${NAME}:${LOWERDIR}"
      fi
    else
        echo $i"[1;36m""Cannot read $NAME - corrupted module?""[0m"; rmdir /memory/images/$NAME
        losetup -d $LODEV
    fi
done
echo -e "done\nbind kernel module...\n"
debug
umount /lib/modules /opt/000-kernel 2>/dev/null

echo -e "done\n Add 'changes on exit' device/file/folder ...\n"
debug
if [ -e /tmp/changes-exit ]; then
    mkdir /memory/images/changes-exit
    if [ -d "$CHNEXIT" ]; then
    mount -o bind $CHNEXIT/changes /memory/images/changes-exit
    elif [ -b /dev/mapper/crypt ]; then
        mount /dev/mapper/crypt /memory/images/changes-exit
    else
        mount -o loop $CHNEXIT /memory/images/changes-exit
    fi
# Not sure if it works with overlay
    echo "  $m  changes-exit"; LOWERDIR="$LOWERDIR /memory/images/changes-exit"
    echo $CHNEXIT/changes >>/tmp/modules
fi

LOWERDIR=`echo $LOWERDIR | sed 's/:$//'` # remove the last :
echo "Mount $UNION_FS_TYPE fs here at /union option: overlay: '$LOWERDIR'"

rm -rf ${CHANGES_MOUNT}/workdir >/dev/null 2>&1
mkdir ${CHANGES_MOUNT}/workdir ${CHANGES_MOUNT}/rootdir
nap
if [ "$UNION_FS_TYPE" = 'aufs' ]; then
    echo "Going to mount command 'mount -t aufs -o br=${CHANGES_MOUNT}/rootdir=rw:${LOWERDIR} none /union'"
    mount -t aufs -o br=${CHANGES_MOUNT}/rootdir=rw:${LOWERDIR} none /union
else
    echo "Going to mount command 'mount -t overlay overlay -o lowerdir=$LOWERDIR,upperdir=${CHANGES_MOUNT}/rootdir,workdir=${CHANGES_MOUNT}/workdir /union'"
    #echo "overlay option metacopy=on is buggy? Disable it for now. We got lots of error 'overlayfs: failed to look up (.profile) for ino (-5)' ..."
    mount -t overlay overlay -o lowerdir=$LOWERDIR,upperdir=${CHANGES_MOUNT}/rootdir,workdir=${CHANGES_MOUNT}/workdir /union
fi
if [ "$?" != 0 ]; then echo "Error mount $UNION_FS_TYPE fs at /union start shell for debugging .."; /bin/sh ; exit 1; fi

# [clearlinux] If /lib is a symlink in the base module then the kernel dir wont appear on the
# actual fs because it is hidden so we need to work around that
mkdir -p /union/lib/modules/$KVER >/dev/null 2>&1
mount -o bind $KERNEL_MOD_MOUNT_PATH /union/lib/modules/$KVER

echo -e "done\nCopy /rootcopy folder...\n"
if param norootcopy; then
    ROOTCOPY=none
    echo $i"skipping /rootcopy directory"
else
    if [ "$ROOTCOPY" ]; then
    locate -d $ROOTCOPY
    if [ $? -eq 0 ]; then echo $i"copying content of $ROOTCOPY directory"; cp -af /mnt/$DEV/$LPTH/. /union/. 2>/dev/null; else fail $ROOTCOPY; ROOTCOPY=none; fi
    else
    ROOTCOPY=none
    echo $i"copying content of $PTH/rootcopy directory"
    cp -af $PTH/rootcopy/. /union/. 2>/dev/null
    fi
fi
mkdir /union/mnt >/dev/null 2>&1; rm -rf /union/dev >/dev/null 2>&1; mkdir /union/dev >/dev/null 2>&1
#echo -e "## Create 7 free loop devices for truecrypt, etc...\n"
#x=`losetup | tail -n1 | cut -d: -f1 | sed 's@/dev/loop@@'`; let y=x+7
#while [ $x -le $y ]; do [ -b /dev/loop$y ] && break || mknod /dev/loop$y b 7 $y; let y=y-1; done

if param nonetwork; then
    echo $i"disabling dhcpcd and NetworkManager services"
    chmod -x /union/etc/rc.d/rc.inet1 /union/etc/rc.d/rc.networkmanager 2>/dev/null
    nma=/union/etc/xdg/autostart/nm-applet.desktop
    test -e $nma && ! grep -q "Hidden=true" $nma && echo "Hidden=true" >> $nma
fi

if [ "$IP" -a -x /union/etc/rc.d/rc.networkmanager ]; then
    if [ -z "`egrep -o " copy2ram( |\$)" /etc/cmdline`" -o -d /mnt/nfs/storage/client-$MAC ]; then
    echo "nameserver $IP" > /union/etc/resolv.conf
    nmc=/union/etc/NetworkManager/NetworkManager.conf; HW=`ifconfig | grep eth0 | cut -dW -f2 | cut -d" " -f2`
    ! grep -q "unmanaged-devices=mac:$HW" $nmc && sed -i '/\[keyfile\]/ a\unmanaged-devices=mac:'$HW'' $nmc
    fi
fi

cp -af /dev/console /union/dev
rm -f /union/etc/mtab
cat > /union/etc/mtab << EOF
#aufs / aufs rw 0 0
proc /proc proc rw 0 0
sysfs /sys sysfs rw 0 0
devtmpfs /dev devtmpfs rw 0 0
devpts /dev/pts devpts rw,mode=0620,gid=5 0 0
EOF
debug
if param copy2ram; then
    [ $SGNDEV = /mnt/isoloop -o $SGNDEV = /mnt/nfs ] && { umount `grep $SGNDEV /etc/mtab | sed -n 1p | cut -d" " -f2`; SGNDEV=$BOOTDEV; }
    CHNDISK=`echo $CHNDEV | cut -b6-8`; SGNDISK=`echo $SGNDEV | cut -b6-8`; REMOVABLE=`cat /sys/block/$SGNDISK*/removable 2>/dev/null`
    if [ -z "`egrep -o " noeject( |\$)" /etc/cmdline`" -a "$CHNDISK" != "$SGNDISK" ]; then
    if [ "$REMOVABLE" = 1 ]; then
        for rdisk in `ls /mnt | grep $SGNDISK`; do
        umount -n /mnt/$rdisk 2>/dev/null && rmdir /mnt/$rdisk
        if [ $? -eq 0 ]; then
            grep -qw "/dev/$rdisk.*iso9660" /etc/fstab && /union/usr/bin/eject /dev/$rdisk
            sed -i "/$rdisk/d" /etc/fstab
        fi
        done
        [ `ls /mnt | grep $SGNDISK` ] || echo $i"[1;36m""finished copying to RAM - booting media can be removed safely""[0m"
    else
        if param nohd; then umount $SGNDEV 2>/dev/null; rmdir $SGNDEV 2>/dev/null; fi
    fi
    fi
fi

# Create debug file:
[ -e /tmp/devices ] && { echo "# Recognized devices:" >$livedbg; cat /tmp/devices >>$livedbg; }
[ $BOOTDEV ] && SGNDEV=$BOOTDEV
echo -e "\n# Booting data device:\n$SGNDEV\n\n#  data found in:\n$PTH\n\n# Changes are stored in:\n$CHANGES\n\n# Non standard /rootcopy dir:\n$ROOTCOPY\n\n# Modules activated during boot time:" >>$livedbg; cat /tmp/modules >>$livedbg

cp -af $livedbg /union/var/log/porteus-livedbg

echo $i"changing root directory"

if param noauto; then
nofstab=yes
    for x in `grep ^/dev/ /etc/fstab | cut -d/ -f3`; do mkdir -p "/union/mnt/$x"; umount -n "/mnt/$x" 2>/dev/null && rmdir "/mnt/$x"; done
else
    grep /dev/ /etc/fstab >> /union/etc/mtab
    for x in `grep ^/dev/ /etc/fstab | cut -d" " -f1`; do
        _mountdir=$(basename $x)
        echo "creating mount directories in union/mnt/${_mountdir} for newly root"
        mkdir -p "/union/mnt/${_mountdir}"
        mount -n --move "/mnt/${_mountdir}" "/union/mnt/${_mountdir}" && rmdir "/mnt/${_mountdir}"
    done
fi
sed -i "s/ ntfs / $NTFS_TYPE /g" /etc/fstab
echo -e "\n# Hotplugged devices:" >> /etc/fstab
mv /union/etc/fstab /union/etc/fstab-orig
cp -f /etc/fstab /union/etc/
rm -rf /usr/* >/dev/null 2>&1
debug

echo "[1m""live system is ready now - starting ${OSDIR}""[0m"
if [ -f /union/lib/systemd/systemd ]; then
    ( cd /union/sbin; rm -f init; ln -sf ../lib/systemd/systemd init )
fi
if [ $? -eq 0 ]; then
    if [ -f /union/usr/sbin/chroot ]; then
    CHROOT='usr/sbin/chroot'
    elif [ -f /union/sbin/chroot ]; then
    CHROOT='sbin/chroot'
    elif [ -f /union/usr/bin/chroot ]; then
    CHROOT='usr/bin/chroot'
    else
    CHROOT='bin/chroot'
    fi
    rm -rf /union/proc /union/sys /union/run /union/tmp /union/srv /union/media >/dev/null 2>&1
    mkdir /union/proc /union/sys /union/run /union/tmp /union/srv /union/media /union/snap >/dev/null 2>&1
    debug
    mount -o move /dev /union/dev
    #set hostname file - only for Debian and Centos os. We can even run chroot /union/ lsb_release to find out more.
    if [ ! -z "$HOSTNAME" ]; then
       echo "$HOSTNAME" > /union/etc/hostname
       if ! grep "$HOSTNAME" /union/etc/hosts >/dev/null 2>&1; then
          echo "127.0.0.1 $HOSTNAME localhost" >> /union/etc/hosts
       fi
       if [ -f /union/etc/sysconfig/network ]; then
          cat <<EOF > /union/etc/sysconfig/network
NETWORKING=yes
HOSTNAME=${HOSTNAME}
EOF
       fi
    fi
    chmod 1777 /union/tmp
    mkdir /union/mnt/live >/dev/null 2>&1
    debug
    echo "Create /tmp/rc.local for this host. search in /union/${CHANGES_MOUNT_SRC}/${HOSTNAME}-rc.local In /etc/rc.local you can detect and exec it"
    if [ -f /union/${CHANGES_MOUNT_SRC}/${HOSTNAME}-rc.local ]; then
	echo "Detect ${HOSTNAME}-rc.local in CHANGES_MOUNT_SRC, copying it to new root /tmp/"
        cp -a /union/${CHANGES_MOUNT_SRC}/${HOSTNAME}-rc.local /union/tmp/rc.local
        chmod 0600 /union/tmp/rc.local
    fi
    echo "Create /tmp/${HOSTNAME}-init.sh for this host. search in ${CHANGES_MOUNT_SRC}/${HOSTNAME}-init.sh"
    if [ -f /union/${CHANGES_MOUNT_SRC}/${HOSTNAME}-init.sh ]; then
	echo "Detected ${HOSTNAME}-init.sh, copying it to /tmp/ in new root"
        cp -a /union/${CHANGES_MOUNT_SRC}/${HOSTNAME}-init.sh /union/tmp/${HOSTNAME}-init.sh
        chmod +x /union/tmp/${HOSTNAME}-init.sh
    fi
    if [ -f /union/${CHANGES_MOUNT_SRC}/${HOSTNAME}-init-playbook.yaml ]; then
        echo "Detected ${HOSTNAME}-init-playbook.yaml, Create /tmp/init-playbook.yaml for this host. In /etc/rc.local you can detect and run ansible-playbook on it to provision the host"
        cp -a /union/${CHANGES_MOUNT_SRC}/${HOSTNAME}-init-playbook.yaml /union/tmp/init-playbook.yaml
        chmod 0600 /union/tmp/init-playbook.yaml
    fi
    debug
    pivot_root /union  /union/mnt/live
    echo "Execute commands in the new root eg. prepare, cleaning up before execting init."
    echo clean up systemd journal
    (rm -rf /var/log/journal/* >/dev/null 2>&1)
    echo "clean up /mnt/live to free up memory if possible ..."
    rm -rf /mnt/live/bin /mnt/live/linuxrc /mnt/live/lib64 /mnt/live/tmp || true
    if ! `ps -ef|grep ntfs-3g >/dev/null 2>&1`; then rm -rf /mnt/live/lib32; fi
    mkdir /var/log/live >/dev/null 2>&1
    mv /mnt/live/*.log /var/log/live/
    mv /mnt/live/var/log/* /var/log/live/
    (cd /mnt ; rm -f portdata ; ln -sf $PORTDATA_DEV portdata)
    echo "portdata device $PORTDATA_DEV"
    echo "remove the systemd mount trouble lines in fstab"
    sed -i '/mapper/d' /etc/fstab
    sed -i '/_DEC/d' /etc/fstab
    if [ -f /tmp/${HOSTNAME}-init.sh ]; then
        echo "executing /tmp/${HOSTNAME}-init.sh"
        /tmp/${HOSTNAME}-init.sh
    fi
    umount /mnt/live/_keystore
    echo done
    debug
    exec $CHROOT . /sbin/init "$@" <dev/console >dev/console 2>&1
else
    echo -e "[31m""!!ERROR!!\nSomething went wrong and I cannot continue.\nPress Ctrl+Alt+Del to reboot.""[0m"
    sh
fi
## find . | cpio --quiet -o -H newc | lzma -7 > ../new-initrd.lz
